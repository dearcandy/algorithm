## 数据结构与算法

### 一、算法复杂度

#### 时间复杂度：

##### 1.基本指令--程序执行消耗的时间单位:

```tex
算数指令、数据移动指令、控制指令
	EG: int a = 1; 
		运行时间 1
		--------------------------
		if(a > 1){} 
		运行时间 1
		--------------------------
		for(int i = 0; i <N; i++){
			System.out.println(i);
		}
  		运行时间= 1【i=0赋值运算】+(n+1)【i<n比较运算】+N【 i++自增运算】+N【sout输出运算】 = 3N+2
```

##### 2.不同算法，运行时间T(n)随输入规模n的增长而不同:

```tex
int a= 1; a = 2; a = 3;  
T(n)=3
-------------------------------------
for(int i = 0; i <n; i++){
			System.out.println(i);
}
T(n)=3n+2
-------------------------------------
for(int i = 0; i <n; i++){
    for(int j = 0; j < n; j++){
        System.out.println(i);
    }		
}
T(n)=3n^2+4n+2
-------------------------------------
```

##### 3.复杂度的大O表示法：

```tex
对于给定的函数g(n),用O(g(n))来表示一下函数的集合：
O(g(n)) = {f(n):存在常量c和n0,使得对所有n>= n0, 有0<=f(n)<=cg(n)}
算法分析中，直接用大O符号表示函数的渐进上界
表示当数据量达到一定程度时，g(n)的增长速度不会超过O(g(n))限定的范围

常见的算法复杂度：
O(1)<O(log(n))<O(n)<O(nlog(n))<O(n^2)<O(e^n)<O(n!)
```

#### 空间复杂度：

```tex
空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。
空间复杂度比较常用的有：O(1)、O(n)、O(n²)
空间复杂度 O(1)
如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
举例：
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

空间复杂度 O(n)
我们先看一个代码：
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)
```

### 二、数组

### 三、二分查找

### 四、字符串

### 五、滑动窗口 	

### 六、链表

### 七、哈希表

### 八、栈和队列

### 九、排序

### 十、二叉树和递归

### 十一、贪心

### 十二、递归

### 十三、回溯

### 十四、深度优先和广度优先

### 十五、位运算和数学方法
